"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDepthValue = exports.checkDepth = exports.listOrdinalConversion = exports.decreasedOrdinalConversion = exports.ordinalConversion = exports.indexRadicalSbrief = exports.indexRadicalBrief = exports.indexRadicalVerbose = exports.indexRadical = exports.getRootIndex = exports.openingRadicalSbrief = exports.closingRadicalBrief = exports.openingRadicalBrief = exports.closingRadicalVerbose = exports.openingRadicalVerbose = exports.nestedRadical = exports.isSimpleIndex = exports.overFractionSbrief = exports.closingFractionSbrief = exports.openingFractionSbrief = exports.closingFractionBrief = exports.openingFractionBrief = exports.closingFractionVerbose = exports.openingFractionVerbose = exports.nestedFraction = void 0;
const span_js_1 = require("../audio/span.js");
const MathspeakUtil = require("./mathspeak_util.js");
const locale_js_1 = require("../l10n/locale.js");
const XpathUtil = require("../common/xpath_util.js");
function nestedFraction(node, expr, opt_end) {
    const depth = MathspeakUtil.fractionNestingDepth(node);
    const annotation = Array.apply(null, Array(depth)).map((_x) => expr);
    if (opt_end) {
        annotation.unshift(opt_end);
    }
    return annotation.join(locale_js_1.LOCALE.MESSAGES.regexp.JOINER_FRAC);
}
exports.nestedFraction = nestedFraction;
function openingFractionVerbose(node) {
    return span_js_1.Span.singleton(nestedFraction(node, locale_js_1.LOCALE.MESSAGES.MS.START, locale_js_1.LOCALE.MESSAGES.MS.FRAC_V));
}
exports.openingFractionVerbose = openingFractionVerbose;
function closingFractionVerbose(node) {
    return span_js_1.Span.singleton(nestedFraction(node, locale_js_1.LOCALE.MESSAGES.MS.END, locale_js_1.LOCALE.MESSAGES.MS.FRAC_V));
}
exports.closingFractionVerbose = closingFractionVerbose;
function openingFractionBrief(node) {
    return span_js_1.Span.singleton(nestedFraction(node, locale_js_1.LOCALE.MESSAGES.MS.START, locale_js_1.LOCALE.MESSAGES.MS.FRAC_B));
}
exports.openingFractionBrief = openingFractionBrief;
function closingFractionBrief(node) {
    return span_js_1.Span.singleton(nestedFraction(node, locale_js_1.LOCALE.MESSAGES.MS.END, locale_js_1.LOCALE.MESSAGES.MS.FRAC_B));
}
exports.closingFractionBrief = closingFractionBrief;
function openingFractionSbrief(node) {
    const depth = MathspeakUtil.fractionNestingDepth(node);
    if (depth === 1) {
        return span_js_1.Span.singleton(locale_js_1.LOCALE.MESSAGES.MS.FRAC_S);
    }
    return span_js_1.Span.singleton(locale_js_1.LOCALE.FUNCTIONS.combineNestedFraction(locale_js_1.LOCALE.FUNCTIONS.radicalNestDepth(depth - 1), locale_js_1.LOCALE.MESSAGES.MS.NEST_FRAC, locale_js_1.LOCALE.MESSAGES.MS.FRAC_S));
}
exports.openingFractionSbrief = openingFractionSbrief;
function closingFractionSbrief(node) {
    const depth = MathspeakUtil.fractionNestingDepth(node);
    if (depth === 1) {
        return span_js_1.Span.singleton(locale_js_1.LOCALE.MESSAGES.MS.ENDFRAC);
    }
    return span_js_1.Span.singleton(locale_js_1.LOCALE.FUNCTIONS.combineNestedFraction(locale_js_1.LOCALE.FUNCTIONS.radicalNestDepth(depth - 1), locale_js_1.LOCALE.MESSAGES.MS.NEST_FRAC, locale_js_1.LOCALE.MESSAGES.MS.ENDFRAC));
}
exports.closingFractionSbrief = closingFractionSbrief;
function overFractionSbrief(node) {
    const depth = MathspeakUtil.fractionNestingDepth(node);
    if (depth === 1) {
        return span_js_1.Span.singleton(locale_js_1.LOCALE.MESSAGES.MS.FRAC_OVER);
    }
    return span_js_1.Span.singleton(locale_js_1.LOCALE.FUNCTIONS.combineNestedFraction(locale_js_1.LOCALE.FUNCTIONS.radicalNestDepth(depth - 1), locale_js_1.LOCALE.MESSAGES.MS.NEST_FRAC, locale_js_1.LOCALE.MESSAGES.MS.FRAC_OVER));
}
exports.overFractionSbrief = overFractionSbrief;
function isSimpleIndex(node) {
    const index = XpathUtil.evalXPath('children/*[1]', node)[0].toString().match(/[^>⁢>]+<\/[^>]*>/g);
    return (index.length === 1) ? [node] : [];
}
exports.isSimpleIndex = isSimpleIndex;
function nestedRadical(node, prefix, postfix) {
    const depth = MathspeakUtil.radicalNestingDepth(node);
    if (depth === 1)
        return postfix;
    return locale_js_1.LOCALE.FUNCTIONS.combineNestedRadical(locale_js_1.LOCALE.FUNCTIONS.radicalNestDepth(depth - 1), prefix, postfix);
}
exports.nestedRadical = nestedRadical;
function openingRadicalVerbose(node) {
    return span_js_1.Span.singleton(nestedRadical(node, locale_js_1.LOCALE.MESSAGES.MS.NESTED, locale_js_1.LOCALE.MESSAGES.MS.STARTROOT));
}
exports.openingRadicalVerbose = openingRadicalVerbose;
function closingRadicalVerbose(node) {
    return span_js_1.Span.singleton(nestedRadical(node, locale_js_1.LOCALE.MESSAGES.MS.NESTED, locale_js_1.LOCALE.MESSAGES.MS.ENDROOT));
}
exports.closingRadicalVerbose = closingRadicalVerbose;
function openingRadicalBrief(node) {
    return span_js_1.Span.singleton(nestedRadical(node, locale_js_1.LOCALE.MESSAGES.MS.NEST_ROOT, locale_js_1.LOCALE.MESSAGES.MS.STARTROOT));
}
exports.openingRadicalBrief = openingRadicalBrief;
function closingRadicalBrief(node) {
    return span_js_1.Span.singleton(nestedRadical(node, locale_js_1.LOCALE.MESSAGES.MS.NEST_ROOT, locale_js_1.LOCALE.MESSAGES.MS.ENDROOT));
}
exports.closingRadicalBrief = closingRadicalBrief;
function openingRadicalSbrief(node) {
    return span_js_1.Span.singleton(nestedRadical(node, locale_js_1.LOCALE.MESSAGES.MS.NEST_ROOT, locale_js_1.LOCALE.MESSAGES.MS.ROOT));
}
exports.openingRadicalSbrief = openingRadicalSbrief;
function getRootIndex(node) {
    const content = XpathUtil.evalXPath('children/*[1]', node)[0].textContent.trim();
    return locale_js_1.LOCALE.MESSAGES.MSroots[content] || content + "제곱근";
}
exports.getRootIndex = getRootIndex;
function indexRadical(node, postfix) {
    const index = getRootIndex(node);
    return index ? index : postfix;
}
exports.indexRadical = indexRadical;
function indexRadicalVerbose(node) {
    return span_js_1.Span.singleton(indexRadical(node, locale_js_1.LOCALE.MESSAGES.MS.ROOTINDEX));
}
exports.indexRadicalVerbose = indexRadicalVerbose;
function indexRadicalBrief(node) {
    return span_js_1.Span.singleton(indexRadical(node, locale_js_1.LOCALE.MESSAGES.MS.ROOTINDEX));
}
exports.indexRadicalBrief = indexRadicalBrief;
function indexRadicalSbrief(node) {
    return span_js_1.Span.singleton(indexRadical(node, locale_js_1.LOCALE.MESSAGES.MS.INDEX));
}
exports.indexRadicalSbrief = indexRadicalSbrief;
function ordinalConversion(node) {
    const children = XpathUtil.evalXPath('children/*', node);
    return span_js_1.Span.singleton(locale_js_1.LOCALE.NUMBERS.wordOrdinal(children.length));
}
exports.ordinalConversion = ordinalConversion;
function decreasedOrdinalConversion(node) {
    const children = XpathUtil.evalXPath('children/*', node);
    return span_js_1.Span.singleton(locale_js_1.LOCALE.NUMBERS.wordOrdinal(children.length - 1));
}
exports.decreasedOrdinalConversion = decreasedOrdinalConversion;
function listOrdinalConversion(node) {
    const children = XpathUtil.evalXPath('children/*', node);
    const content = XpathUtil.evalXPath('content/*', node);
    return span_js_1.Span.singleton(locale_js_1.LOCALE.NUMBERS.wordOrdinal(children.length - content.length));
}
exports.listOrdinalConversion = listOrdinalConversion;
function checkDepth(node) {
    const roleList = [];
    const depth = getDepthValue(node, roleList);
    return (depth > 3) ? [] : [node];
}
exports.checkDepth = checkDepth;
function getDepthValue(node, roleList) {
    const role = node.getAttribute('role');
    const index = roleList.indexOf(role) > -1;
    if (!index) {
        roleList.push(role);
    }
    const children = XpathUtil.evalXPath('children/*', node);
    let max = 0, cur = 0;
    if (children.length) {
        children.forEach(child => {
            cur = getDepthValue(child, roleList);
            cur > max ? max = cur : max;
        });
        return (max + 1);
    }
    return 0;
}
exports.getDepthValue = getDepthValue;
