{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-11 01:13:08 "},"Chapter0/":{"url":"Chapter0/","title":"第零章","keywords":"","body":"第零章 gitbook发布github pages教程 搭建Gitbook并通过Git推送部署 上传到Github仓库的master分支 为了提交方便，可以创建一个脚本文件commit.sh来自动执行将本地仓库push到远端仓库的指令，脚本如下 # 保存所有的修改 echo '执行命令：git add -A\\n' git add -A # 把修改的文件提交 echo \"执行命令：git commit -m 'update notebook CSAPP'\\n\" git commit -m 'update gitbook' # 将本地仓库推送至远程仓库 echo '执行命令：git push origin master\\n' git push origin master 编写好后，在终端运行以下命令即可： $ bash commit.sh 上传到 Github 仓库的 gh-pages 分支 打包命令太多，为了部署方便，可以创建一个脚本文件 deploy.sh 来自动执行，内容如下： # 构建Gitbook echo '执行命令：gitbook build .' gitbook build . # 进入生成的文件夹 echo \"执行命令：cd ./_book\\n\" cd ./_book # 初始化一个仓库，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪 echo \"执行命令：git init\\n\" git init # 解决使用git add命令时报错LF will be replaced by CRLF的问题 echo '执行命令：git config auto.crlf true\\n' git config auto.crlf true # 保存所有的修改 echo \"执行命令：git add -A\" git add -A # 把修改的文件提交 echo \"执行命令：commit -m 'deploy gitbook'\" git commit -m 'deploy gitbook' # 发布到 https://.github.io/ echo \"执行命令：git push -f 仓库地址.git master:gh-pages\" git push -f 仓库地址.git master:gh-pages # 返回到上一次的工作目录 echo \"回到刚才工作目录\" cd - 文件保存后，在终端执行如下命令，把生成的项目推送到 github 仓库上的 gh-pages 分支： $ bash deploy.sh 常用的Gitbook插件 [1]为什么要用插件？ Gitbook 默认自带以下 5 个插件： highlight：代码高亮 search：导航栏查询功能（不支持中文） sharing：右上角分享功能 font-settings：字体设置（最上方的\"A\"符号） livereload：为 Gitbook 实时重新加载。 Gitbook 插件可以解决一些网站不太方便的地方，如侧边栏导航不能收缩，自带搜索不支持中文等问题。 [2]插件安装方法： Step1：在项目的根目录中创建 book.json 文件，然后在 plugins 参数中添加插件名。 Step2：使用 gitbook install 来安装插件，重启服务 gitbook serve 或者重新打包 gitbook build 就能看见效果。 注意： 编写 json 时字符串不能用“单引号”括起，最后的那个不能有“逗号”。 如果要卸载自带的 font-settings，插件处应写成 -fontsettings，中间不要加 -。 gitbook install 命令有时会出现问题，多试几次可能就好了。 gitbook install 命令安装慢，而且是全部插件都安装一遍，如果只安装一个插件的话建议使用npm命令安装。 以下是我配好的 book.json 文件，仅供参考。 { \"title\": \"标题\", \"description\": \"描述信息\", \"author\": \"作者\", \"output.name\": \"site\", \"language\": \"zh-hans\", \"gitbook\": \"3.2.3\", \"root\": \".\", \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\", \"expandable-chapters-small\", \"splitter\", \"back-to-top-button\", \"expandable-chapters-small\", \"-sharing\", \"github\", \"code\", \"page-toc-button\" , \"tbfed-pagefooter\", \"rss\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/YGVICTOR/my_blog\" }, \"hide-element\": { \"elements\": [\".gitbook-link\"] }, \"page-toc-button\": { \"maxTocDepth\": 2, \"minTocSize\": 2 }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy 版权信息\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"rss\":{ \"title\": \"标题\", \"description\": \"描述信息\", \"author\": \"作者\", \"feed_url\": \"https://xxx.xxx.xxx/rss\", \"site_url\": \"https://xxx.xxx.xxx/\" } } } 注意，每次修改完上述文件后，需要执行 $ gitbook install $ gitbook serve 常见错误 安装gitbook init和if (cb) cb.apply(this, arguments)，cb.apply is not a function 将下面三行代码注释掉即可 fs.stat = statFix(fs.stat) fs.fstat = statFix(fs.fstat) fs.lstat = statFix(fs.lstat) 安装mathjax-pro插件 # 切成v10.24.1，必须是10.x，再高报错 $ nvm install v10.24.1 $ nvm use 10.24.1 $ nvm alias default v10.24.1 # 安装gitbook $ npm install gitbook-cli -g # 安装mathjax $ npm install -g mathjax@2.7.6 # 安装mathjax plugin，这步最重要！！！，之前gitbook install一直失败 $ npm install gitbook-plugin-mathjax # 最终更新gitbook $ gitbook install ./ Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-17 22:49:36 "},"Chapter1/":{"url":"Chapter1/","title":"第一章","keywords":"","body":"第一章 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-12 21:32:13 "},"Chapter1/衣.html":{"url":"Chapter1/衣.html","title":"第1节：衣","keywords":"","body":"第1节：衣 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-12 21:32:13 "},"Chapter1/食.html":{"url":"Chapter1/食.html","title":"第2节：食","keywords":"","body":"第2节：食 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-12 21:32:13 "},"Chapter1/住.html":{"url":"Chapter1/住.html","title":"第3节：住","keywords":"","body":"第3节：住 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-12 21:32:13 "},"Chapter1/行.html":{"url":"Chapter1/行.html","title":"第4节：行","keywords":"","body":"第4节：行 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-12 21:32:13 "},"Chapter2/":{"url":"Chapter2/","title":"第二章","keywords":"","body":"第二章 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-12 21:32:13 "},"Chapter3/":{"url":"Chapter3/","title":"第三章","keywords":"","body":"第三章 程序的机器级表示 本小节内容来自：视频讲解 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-13 21:17:15 "},"Chapter3/程序的机器级表示.html":{"url":"Chapter3/程序的机器级表示.html","title":"第1节：程序的机器级表示","keywords":"","body":"Chapter 3: Machine-Level Representation of Programs(程序的机器级表示) 在第一章讲述计算机漫游时，我们曾提到过编译系统的工作流程。本节我们详细介绍一下C语言、汇编代码以及机器代码之间的关系。理解汇编代码与原始C代码之间的关系，是理解计算机如何执行程序的关键一步。因此，稍微花一些时间来学习一下汇编语言，对理解计算机系统是非常有必要的。 我们先来简单了解一下Intel处理器的发展历史。1978年Intel发布了第一款微处理器-8086，在接下来的四十多年里，Intel不断地推出新的处理器，从最早的16位扩展到32位，近些年又扩展到64位，视频中代码的运行环境就是Intel-x86-64位的处理器，操作系统是linux。 接下来，我们看一个C代码的例子，这个示例中包含两个源文件，一个是main.c，另外一个是mstore.c,我们可以通过图中的命令编译这些代码，其中gcc指的就是gcc编译器，它是linux系统上默认的编译器 ，其中编译选项-Og是用来告诉编译器生成符合原始C代码整体结构的机器代码。在实际项目中，为了获得更高的性能，会使用-O1或者-O2,甚至更高的编译优化选项。但是使用高级别的优化产生的代码会严重变形，导致产生的机器代码与最初的源代码之间的关系难以理解，此处为了方便理解，因此选择-Og这个优化选项。-o后面跟的参数prog表示生成可执行文件的文件名。关于更多链接方面的知识，将会在第七章做更详细的讲解。 linux > gcc -Og -o prog main.c mstore.c 首先，我们以源文件mstore.c为例，看一下代码与汇编代码之间的关系，使用图中的这条命令可以生成mstore.c所对应的汇编文件mstore.s,其中-S这个编译选项就是告诉编译器GCC产生的文件为汇编文件，我们可以用编辑器(vim)打开这个汇编文件。 其中以\".\"开头的行都是指导汇编器和链接器工作的伪指令，也就是说我们完全可以忽略这些以“.\"开头的行。 删除了无关的信息之后，剩余这些汇编代码与源文件中C代码是相关的，接下来我们看一下这段C程序所对应的第一条汇编代码。pushq这条指令的意思是将寄存器rbx的值压入程序栈进行保存。 在IntelX86-64的处理器中包含了16个通用目的的寄存器，这些寄存器用来存放整数数据和指针，图中显示的这16个寄存器，它们的名字都是%r开头的。 在详细介绍寄存器之前，我们首先需要搞清楚两个概念，调用者保存寄存器和被调用者保存寄存器，例如图中的这个例子，函数A调用了函数B，因此函数A称为调用者，函数B称为被调用者，由于调用了函数B，寄存器rbx在函数B中被修改了，逻辑上寄存器rbx的内容在调用函数B的前后应该保持一致。 解决这个问题有两个策略。一个是函数A在调用函数B之前，提前保存寄存器rbx的内容，执行完函数B之后，再恢复寄存器rbx原来存储的内容，这种策略就称为调用者保存。 另外一个策略就是函数B在使用寄存器rbx之前，先保存寄存器rbx的值，在函数B返回之前，先恢复寄存器rbx原来存储的内容，这种策略被称之为被调用者保存。 对于具体使用哪一种策略，不同的寄存器被定义为不同的策略，具体如图所示。 寄存器rbx被定义为被调用者保存寄存器(callee-saved register)，因此，pushq就是用来保存寄存器rbx的内容，在函数返回之前，使用了pop命令，恢复寄存器rbx的内容。 第二行汇编代码的含义是将寄存器rdx的内容复制到rbx,根据寄存器用法的定义，函数multstore的三个参数分别保存在寄存器rdi,rsi和rdx中，这条指令执行结束后，寄存器rdx与寄存器rbx内容一致，都是dest指针所指向内存的地址， mov指定的后缀q,表示数据的大小，由于早期的机器是16位的，后来才扩展到32位，因此intel用字(word)表示16位的数据类型。所以，32位的数据类型称为双字，64位的数据类型称为四字。图中的表格给出了C语言的基本数据类型对应的汇编后缀表示， 大多数GCC生成的汇编指令都有一个字符后缀来来表示操作数的大小，例如数据传送指令就有四个变种，分别为movb,movw,movl以及movq， 其中movb是Move Byte的缩写,表示传送字节；movw是Move Word的缩写，表示传送字，movl表示传送双字，其中l是long word的缩写；movq则表示传送4字。 call指令对应于C代码中的函数调用，这一行代码比较容易理解，该函数的返回值会被保存在寄存器rax中，因此，寄存器rax中保存了x和y的乘积的结果。 下一条指令将寄存器rax的值传送到内存保存，内存的地址就是保存在寄存器 rbx中，最后一条指令ret，就是函数返回。 接下来我们看一下C代码是如何被翻译成机器代码的，我们只需要将编译选项从-S替换为-c linux > gcc -Og -S mstore.c linux > gcc -Og -c mstore.c 执行这条命令，即可生产mstore.c对应的机器代码文件mstore.o,由于该文件是二进制的，所以无法直接查看，这里我们需要有一个反汇编工具-objdump; 汇编器将汇编代码翻译为二进制机器代码，那么反汇编器就是将机器代码翻译成汇编代码，通过图中的命令，我们可以查看mstore.中的相关信息。 linux > objdump -d mstore.o 通过对比反汇编得到的汇编代码与编译器直接生成的汇编代码，可以发现二者存在细微的差别，反汇编代码省略了很多指令的后缀\"q\"，但在call和ret指令添加了后缀q，由于q只是代表大小指示符，大多数情况下是可以省略的。 通过上述描述，我们大概了解了C代码，汇编代码，机器代码之间的关系。 总结 上述汇编执行过程如下： 被调用者保存机制先调用push存储寄存器%rbx中的值； 修改%rbx寄存器，将函数第三个参数的值直接放入寄存器rbx中； 调用函数mult2，函数的返回值放入寄存器rax中； 找到寄存器rbx指向的地址，将那个地址上的值修改为rax寄存器的值（也就是mult2函数的返回值） 被调用者保存机制将寄存器rbx中的值恢复 结束程序。 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-16 12:11:37 "},"Chapter3/寄存器与数据传送指令.html":{"url":"Chapter3/寄存器与数据传送指令.html","title":"第2节：寄存器与数据传送指令","keywords":"","body":"在讲述第一章计算机系统漫游时，提到过计算机系统中信息的存储部件，相对于内存和硬盘，大家可能对寄存器会陌生一些，接下来我们详细介绍一下寄存器的相关知识。 最早8086的处理器中，包含8个16位的通用寄存器，具体如图所示。每个寄存器都有特殊的功能，它们的名字就反映了不同的用途。 当处理器从16位扩展到32位时，寄存器的位数也随之扩展到了32位 直到今天64位的处理器中，原来8个16位寄存器已经扩展成了64位，除此之外，还增加了8个新的寄存器。在一般的程序中，不同的寄存器扮演着不同的角色，相应的编程规范规定了如何使用这些寄存器。 例如，寄存器rax用来保存函数的返回值，寄存器rsp用来保存程序栈的结束位置，除此之外，还有6个寄存器可以用来传递函数参数，在了解了这些寄存器的用法之后，再去理解汇编代码就会容易多了。 接下来我们看一下指令的相关知识。大多数指令包含两部分，操作码和操作数，例如，图中的这几条指令，movq,addq,'subq,这部分被定义为操作码，它决定了CPU执行操作的类型，操作码之后的这部分是操作数，大多数指令具有一个或者多个操作数，不过像ret返回指令，是没有操作数的。 不同指令的操作数大致可以分为三类，分别是立即数，寄存器，以及内存引用，在AT&T格式的汇编中，立即数是以$开头的，后面跟一个整数，不过这个整数需要满足标准C语言的定义；操作数是寄存器的情况也比较容易理解，即使在64位的处理器上，不仅64位的寄存器可以作为操作数，32位，16位甚至8位的寄存器都可以作为操作数。需要注意的是，图中这种寄存器带了小括号的情况，它所表示的是内存引用。 接下来，我们重点看一下内存引用的情况。 我们通常将内存抽象为一个字节数组，当需要从内存中存取数据时，需要获取目的数据的起始地址addr,以及数据长度b,我们使用符号M_b[addr] 来表示内存引用。为了简便，通常会省略下标b，最常用的内存引用包含4部分，分别是一个立即数，一个基址寄存器，一个变址寄存器和一个比例因子， \r Imm \\rightarrow Immediate(立即数)\\\\\r r_b \\rightarrow Base Register(基址寄存器) \\\\\r r_i \\rightarrow Index Register(变址寄存器) \\\\\r s \\rightarrow Scale Factor(比例因子)[1,2,4,8]\r 引用数组元素时，会使用到这种通用的形式，有效地址是通过立即数与基址寄存器的值相加，再加上变址寄存器与比例因子的乘积， \r Imm(r_b,r_i,s) \\rightarrow Imm + R[r_b] + R[r_i]*s\r 比例因子的取值必须是1，2，4，8；实际上，比例因子的取值是与源代码中定义的数组类型是相关的。编译器会根据数组类型来确定比例因子的数值，例如，定义char类型的数组，比例因子就是1，int类型，比例因子就是4，至于double类型，比例因子就是8，其他形式的内存引用都是这种普通形式的变种，省略了其中的某些部分，图中列出了内存引用的其他形式，需要特别注意到两种是不带$符号的立即数，和带了括号的寄存器。 在上一节中，我们提到过move类指令，它包含movb,movw,movl以及movq这四条指令，这些指令执行相同的操作，都是把数据从源位置复制到目的位置，主要区别，在于他们所操作的数据大小不同，具体如图所示。 对于MOV类指令，含有两个操作数，一个称为源操作数，一个称为目的操作数；对于源操作数，可以是立即数，一个寄存器，或者是内存引用；由于目的操作数是用来存放源操作数的内容，所以目的操作数要么是一个寄存器，要么是一个内存引用，注意，目的操作数不能是一个立即数；除此之外，x86-64处理器有一条限制，就是mov指令的源操作数和目的操作数不能都是内存的地址， 当需要将一个数从内存的一个位置复制到另一个位置时，应该如何操作？ 此时，需要两条mov指令来完成， mov memory, register mov register, memory 第一条指令将内存源位置的数据加载到寄存器，第二条指令再将该寄存器的值写入内存的目的位置。接下来，我们看几个有关mov指令的例子。 图中的指令给出了不同原操作数和目的操作数的组合，第一个是源操作数，第二个是目的操作数，mov指令的后缀与寄存器的大小一定得是匹配的，例如寄存器%eax是32位，与双字l对应，寄存器%al是8位，与字节b对应，除此之外，mov指令还有一个特殊的情况需要了解一下。 当movq指令的源操作数是64位时，该立即数只能是32位的补码表示，然后对该数值进行符号位扩展之后，将得到的64位数传送到目的位置，这个限制会带来一个问题，当立即数是64位时应该如何处理？这里引入了一个新的指令，movabsq， 该指令的源操作数可以是任意的64位立即数，需要注意的是，目的操作数仅能是寄存器。 接下来，我们通过一个例子来看一下，使用mov指令进行数据传送时，对于目的寄存器的修改结果是怎么样的 movabsq $0x0011223344556677, %rax movb $-1 %al movw $-1 %ax movl $-1 %eax 首先，使用movabsq指令将一个64位的立即数复制到寄存器rax,此时，寄存器rax内保存的数值如图所示、 接下来，使用movb指令将立即数-1复制到寄存器al，寄存器al的长度为8，与movb指令所操作的数据大小一致。此时，寄存器rax的低8位发生了改变， 第三条指令movw 是将立即数-1复制到寄存器ax,寄存器低16位发生了变化。 当指令movl将立即数-1复制到寄存器eax时，此时寄存器rax不仅仅是低32位发生了变化，而且高32位也发生了变化， 当movl的目的操作数是寄存器时，它会把该寄存器的高4节设置位0，这是x86-64处理器的一个规定。即任何位寄存器生成32位值的指令都会把该寄存器的高位部分置为0，以上介绍的都是源操作数与目的操作数大小一致的情况。 当源操作数数位小于目的操作数时，我们需要对目的操作数剩余的字节进行0扩展或者符号位扩展，零扩展数据传送指令有五条，其中字符z是zero的缩写。指令最后的两个字符都是大小指标符，第一个字母表示源操作数的大小，第二个字母表示目的操作数的大小。 符号位扩展传送指令有6条，其中字符s是sign的缩写，同样，指令最后的两个字符也是大小指示符。 对比零扩展和符号位扩展，我们可以发现符号位扩展比零扩展多了一条4字节到8字节的扩展指令，为什么零扩展没有movzlq的指令呢？是因为这种情况的数据传送可以使用movl指令来实现； 最后，符号位扩展还有一条没有操作数的特殊指令cltq,该指令的源操作数总是寄存器eax,目的操作数总是寄存器rax, cltq的效果和 movslq %eax, %rax Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-18 00:29:54 "},"Chapter3/栈与数据传送指令.html":{"url":"Chapter3/栈与数据传送指令.html","title":"第3节：栈与数据传送指令","keywords":"","body":"上一节我们讲述了数据传送指令的相关知识，本期先从计算机系统的角度，看一下程序执行时数据传送的情况。 在第一章，我们提到过helloworld程序加载运行的大致过程。最初，可执行文件是保存在硬盘上，通过shell程序，将可执行程序从硬盘加载到内存。此时，程序指令以及数据都保存在内存中，CPU要执行程序，需要从内存中读取指令和数据。实际上，在一些程序的执行过程中，需要在CPU的内存之间进行频繁的数据存取。例如，CPU执行一个简单的加法操作$ c = a + b$ , 那么首先通过CPU执行数据传送指令将a和b的值从内存读取到寄存器内，寄存器就是CPU内的一种数据存储部件，只不过是容量比较小。我们以x86-64处理器为例 寄存器rax的大小是64个比特位，也就是8个字节，如果变量a是long类型，需要占用8个字节，因此，寄存器rax全部的数据位都用来保存变量a,如果变量a是int类型，那么只需要用4个字节来存储该变量，那么，只需要用到寄存器的低32位就够了， 如果变量a是short类型，则只需要用到寄存器的低16位， 对于寄存器rax,如果使用全部的64位，用符号%rax来表示，如果只用到低32位，可以用符号%eax来表示，对于低16位和低8位，则分别用%ax和%al来表示，虽然使用了不同的表示符号，但实际上仅仅只是针对同一寄存器的不同数位进行操作。处理器完成加法运算之后，再通过一条数据传送指令将计算结果保存到内存中。正是因为数据传送在计算机系统中是一个非常频繁的操作，所以了解一下数据传输的指令对理解计算机系统会有很大的帮助。接下来我们看一个数据传送的代码实例。 int main(){ long a = 4; long b = exchange(&a,3); printf(\"a = %ld, b = %ld \\n\",a,b); return 0; } long exchange(long *xp, long y){ long x = *xp; *xp = y; return x; } main函数中定义了变量a，并且赋值为4，随后调用了exchange函数，该函数执行返回后，变量a的值会替换为3，变量b将保存变量a原来的值4 $ linux > a = 3, b= 4 我们重点看一下函数exchange对应的汇编指令 exchange: movq (%rdi), %rax movq %rsi, (%rdi) ret 从汇编的角度看，exchange将第一个参数的地址存取的值返回，放入%rax寄存器；然后将第二个参数的值复制到第一个参数那个地址里； 函数exchange由三条指令实现，包含两条数据传送指令和一条返回指令，根据寄存器使用的惯例，寄存器%rdi和%rsi分别用来保存函数传递的第一个和第二个参数，因此寄存器rdi中保存了xp的值，寄存器rsi保存了变量y的值，这段汇编代码并没有显式地将这部分表示出来，需要注意一下，第一条mov指令从内存中读取数据放入到寄存器，内存地址保存在寄存器rdi中，目的操作数是寄存器rax,由于最后exchange函数需要返回变量x的值，所以这里直接将变量x放入寄存器rax中，第二条mov指令，将变量y的值写入到内存里，变量y存储在寄存器rsi中，内存地址保存在寄存器rdi中，也就是xp指向的内存的位置。通过这个例子，我们可以看到C语言中所谓的指针其实就是地址。 此外，还有两个数据传送指令需要借助程序栈。栈是一种数据结构，通过push操作把数据压入栈，通过pop操作删除数据。 栈具有一个特性，就是弹出的数据永远是最近被压入的且仍然在栈中，这个程序栈本质是内存的一个区域，在第一章计算机系统漫游时，我们曾分析过程序运行时的内存分布。图中的这个区域就是程序栈，栈的增长方向是从高地址向低地址。因此，栈顶元素是所有栈中元素地址最低的，根据惯例，栈是倒过来画的，栈顶在底部，栈底在顶部， 例如我们需要保存寄存器rax内存的数据0x123,可以使用pushq %rax指令把数据压入栈内，该指令执行的过程可以分解为两步，首先指向栈顶的寄存器rsp进行一个减法操作，例如，压栈之前，栈顶指针rsp指向栈顶位置，此处地址为0x108，压栈的第一步就是寄存器rsp的值减8，此时指向内存地址是0x100，然后将需要保存的数据复制到新的栈顶地址，此时内存地址0x100处将保存寄存器rax中存储的数据0x123，实际上pushq指令等效于 sub $8, %rsp mov %rax, (%rsp) 它们之间的区别是pushq这一条指令只需要一个字节，而图中的这两条指令需要8个字节存储，说到底，push指令的本质还是将数据写入到内存中，那么与之相对应的pop指令就是从内存中读取数据，并修改栈顶指针，例如popq %rbx就是将栈顶保存到数据复制到寄存器rbx中，pop指令的操作也可以分解为两步， movq (%rsp), %rbx add $8, %rsp 首先从栈顶位置读出数据，复制到寄存器rbx,此时栈顶指针rsp指向的内存地址是0x100, 然后将栈顶指针加8，pop后栈顶指针rsp指向的内存地址是0x108, pop后栈顶指针rsp指向的地址是0x108,实际上pop指令是通过修改栈顶指针所指向的内存地址来实现数据删除的，此时内存地址0x100内所保存的数据0x123仍然存在， 直到下次push操作，此处保存的数值才会被覆盖。 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-19 23:27:03 "},"Chapter3/算术和逻辑运算指令.html":{"url":"Chapter3/算术和逻辑运算指令.html","title":"第4节：算术和逻辑运算指令","keywords":"","body":"在上一小节，我们讲述了数据传送指令的相关知识，本节我们来看一下有关算术和逻辑操作的指令。 首先，我们看一下指令leaq,它实现的功能是加载有效地址，q表示地址的长度是四个字 \r leaq \\space S,D \\rightarrow Load \\space Effective \\space Address\r 由于x86-64位处理器上，地址长度都是64位，因此不存在leab、leaw这类有关大小的变种，例如指令leaq 7(%rdx, %rdx,4), %rax表示的是将有效地址复制到寄存器%rax中，源操作数看上去与内存引用的格式类似，有效地址的计算方式与之前讲到的内存地址的计算方式一致，可以通过公式Imm(r_b,r_i,s) \\rightarrow Imm + R[rb]+R[r_i]*s 得到，假设寄存器rdx内保存的数值为x，那么有效地址的值为 5x+7 。 \r \\%rdx \\leftarrow x \\\\\r Effective \\space Address: 7+\\%rdx + \\%rdx*4=5x+7\r 注意，对于leaq指令所执行的操作并不是去内存地址 (5x+7) 处读取数据，而是将有效地址(5x+7) 这个值直接写入到目的寄存器rax,因此这个地方需要特别注意一下，除了加载有效地址的功能，leaq指令还可以用来表示加法和有限的乘法运算(在寄存器内的加法运算) long scale(long x, long y, long z){ long t = x + 4*y + 12*z; return t; } 经过编译后，这段代码是通过三条leaq指令来实现的； scale: leaq(%rdi,%rsi,4), %rax leaq(%rdx,%rdx,2), %rdx leaq(%rax,%rdx,4), %rax ret 上述代码等价于 \r \\%rax \\leftarrow x+4y \\\\\r \\%rdx \\leftarrow z + 2*z = 3z \\\\\r \\%rax \\leftarrow (x+4y) + 4(3*z) = x+4y+12z\r 接下来，我们看一下，如何通过leaq指令实现算术运算，根据寄存器的使用惯例，参数x,y,z分别保存在寄存器rdi,rsi,rdx中，还是根据内存引用的计算公式，第一条指令的源操作数就对应于$x+4y$,指令leaq将该数值保存到目的寄存器rax中，接下来关于z*12的乘法运算会有一些复杂，需要分成两步，第一步首先计算3*z的数值，第二条leaq指令执行完毕，此时寄存器rdx中保存的值是3*z，第三步再把(3*z)作为一个整体乘以4，再和寄存器rax中的值(x+4y)相加得到最终结果。通过两步运算最终得到$z*12$。 此时，为什么不能使用leaq (%rax, %rdx,12),%rax这条指令直接一步得到我们期望的结果？这主要是由于比例因子只能是1，2，4，8这四个数中的一个。因此，需要将12进行分解。 接下啦，我们看一组一元操作指令，这一组指令只有一个操作数，因此该操作数既是源操作数也是目的操作数，操作数可以是寄存器，也可以是内存地址 我们再来看一组二元操作指令，这一组指令包含两个操作数，第一个操作数是源操作数，这个操作数可以是立即数，寄存器或者内存地址，，第二个操作数既是源操作数，又是目的操作数，这个操作数可以是寄存器或者内存地址，但不能是立即数。 接下来，我们看一组例子，一开始，内存以及寄存器中所保存的数据如图所示 加法指令addq %rcx,(%rax)是将内存地址0x10内的数据与寄存器rcx相加，二者之和再存储到内存地址0x100处，该指令执行完毕后，内存地址0x100所存储的数据由0xFF变成了0x100。（寻址，取数，相加） 减法指令subq %rdx, 8(%rax)是将内存地址0x108内的数据减去寄存器rdx内的数据，二者之差再存储到内存地址0x108处，该指令执行完毕后，内存地址0x108处所存储的数据由0xAB变为0xA8； 对于加1指令incq 16(%rax),就是将内存地址0x110内存存储的数加1，结果是内存地址0x110处所存储的数据由0x13变成了0x14。 最后一条指令subq %rdx,%rax是将寄存器rax内的值减去寄存器rdx内的值，最终寄存器rax的值由0x100变成0xFD 在之前的章节中，我们讲过移位操作，图中的这一类指令，是用来进行移位运算的。左移指令有两个，分别是SAL和SHL,二者的效果是一样的，都是在右边填零。 右移指令不同，分为算术右移和逻辑右移，算术右移需要填符号位，逻辑右移需要填0，这与c语言中所讲述的移位操作是一致的。 对于移位量k，可以是一个立即数，或是放在寄存器cl中的数，对于移位指令，只允许以特定的寄存器%cl作为操作数，其他的寄存器不行，这里需要特别注意一下，由于寄存器cl的长度为8，原则上移位量的编码范围可达2的8次方-1(255), 实际上，对于w位的操作数进行移位操作，移位量是由寄存器cl的低m位来决定，也就是说，对于指令salb,当目的操作数是8位，移位量由寄存器cl的低3位来决定；对于指令salw,移位量则是由寄存器cl的低4位来决定；对于指令salw，移位量则是由寄存器cl的低4位来决定，以此类推，双字对应的是低5位，四字对应的是低6位。接下来，我们通过一个例子来讲述一下移位指令的用途。 long arith(long x, long y, long z){ long t1 = x^y; long t2 = z * 48; long t3 = t1&0x0F0F0F0F; long t4 = t2 - t3; return t4; } 图中的这段代码，涉及了多种操作 arith: xorq %rsi, %rdi leaq (%rdx,%rdx,2), %rax salq $4, %rax andl $252645135, %edi subq %rdi,%rax ret \r \\%rdi \\leftarrow x \\space xor \\space y \\\\\r \\%rax \\leftarrow 3z \\\\\r \\%rax \\leftarrow 3z * 16 \\\\\r \\%edi \\leftarrow (x \\space xor \\space y) \\space AND \\space 252645135 \\\\\r \\% rax \\leftarrow 48z - ((x \\space xor \\space y)\\space AND \\space 252645135 ) \r 我们重点看一下z*48这行代码对应的汇编指令,这个计算过程被分解成了两步，第一步，首先计算3*z，指令leaq来实现，计算结果保存到保存到寄存器rax。第二步，将寄存器rax进行左移4位，左移4位的操作是等效于乘以2的四次方，也就是乘以16，通过一条leaq指令和一条左移指令，来实现乘法操作，主要是因为乘法指令的执行需要更长时间。因此编译器在生成汇编指令时，会优先考虑更高效的方式。此外，还有一些特殊的算术指令，这里就不一一展开描述了。 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-22 00:23:21 "},"Chapter4/":{"url":"Chapter4/","title":"第四章","keywords":"","body":"第四章 Copyright © 版权信息 all right reserved，powered by Gitbook该文件修订时间： 2024-06-12 21:32:13 "}}