在上一小节，我们讲述了数据传送指令的相关知识，本节我们来看一下有关算术和逻辑操作的指令。首先，我们看一下指令`leaq`,它实现的功能是加载有效地址，q表示地址的长度是四个字
$$
leaq \space S,D \rightarrow Load \space Effective \space Address
$$
由于x86-64位处理器上，地址长度都是64位，因此不存在`leab`、`leaw`这类有关大小的变种，例如指令`leaq 7(%rdx, %rdx,4), %rax`表示的是将有效地址复制到寄存器`%rax`中，源操作数看上去与内存引用的格式类似，有效地址的计算方式与之前讲到的内存地址的计算方式一致，可以通过公式$ Imm(r_b,r_i,s) \rightarrow Imm + R[rb]+R[r_i]*s $得到，假设寄存器`rdx`内保存的数值为x，那么有效地址的值为$ 5x+7 $ 。


$$
\%rdx \leftarrow x \\
Effective \space Address: 7+\%rdx + \%rdx*4=5x+7
$$
注意，对于`leaq`指令所执行的操作并不是去内存地址$ (5x+7) $处读取数据，而是将有效地址$(5x+7)$ 这个值直接写入到目的寄存器`rax`,因此这个地方需要特别注意一下，除了加载有效地址的功能，`leaq`指令还可以用来表示加法和有限的乘法运算

```c
long scale(long x, long y, long z){
    long t = x + 4*y + 12*z;
    return t;
}
```

经过编译后，这段代码是通过三条`leaq`指令来实现的；

```shell
scale:
	leaq(%rdi,%rsi,4), %rax
	leaq(%rdx,%rdx,2), %rdx
	leaq(%rax,%rdx,4), %rax
ret
```



上述代码等价于
$$
\%rax \leftarrow x+4y \\
\%rdx \leftarrow z + 2*z = 3z \\
\%rax \leftarrow (x+4y) + 4(3*z) = x+4y+12z
$$


接下来，我们看一下，如何通过`leaq`指令实现算术运算，根据寄存器的使用惯例，参数x,y,z分别保存在寄存器`rdi`,`rsi`,`rdx`中，还是根据内存引用的计算公式，第一条指令的源操作数就对应于$x+4y$,指令`leaq`将该数值保存到目的寄存器`rax`中，接下来关于$z*12$的乘法运算会有一些复杂，需要分成两步，第一步首先计算$3*z$的数值，第二条`leaq`指令执行完毕，此时寄存器`rdx`中保存的值是`3*z`，第三步再把$(3*z)$作为一个整体乘以4，再和寄存器`rax`中的值$(x+4y)$相加得到最终结果。通过两步运算最终得到$z*12$。

此时，为什么不能使用`leaq (%rax, %rdx,12),%rax`这条指令直接一步得到我们期望的结果？这主要是由于<u>**比例因子**</u>只能是1，2，4，8这四个数中的一个。因此，需要将12进行分解。

接下啦，我们看一组一元操作指令，这一组指令只有一个操作数，<u>**因此该操作数既是源操作数也是目的操作数，操作数可以是寄存器，也可以是内存地址**</u>

<img src=".\pic\image-20240620003715228.png" alt="image-20240620003715228" style="zoom:67%;" />

我们再来看一组二元操作指令，这一组指令包含两个操作数，第一个操作数是<u>**源操作数**</u>，这个操作数可以是<u>**立即数，寄存器或者内存地址，**</u>，第二个操作数既是源操作数，又是目的操作数，<u>**这个操作数可以是寄存器或者内存地址，但不能是立即数**</u>。

<img src=".\pic\image-20240620004202380.png" alt="image-20240620004202380" style="zoom:67%;" />

接下来，我们看一组例子，一开始，内存以及寄存器中所保存的数据如图所示，加法指令`addq %rcx,(%rax)`是将内存地址0x10内的数据与寄存器`rcx`相加，二者之和再存储到内存地址0x100处，该指令执行完毕后，内存地址0x100所存储的数据由0xFF变成了0x100，

减法指令`subq %rdx, 8(%rax)`是将内存地址0x108内的数据减去寄存器`rdx`内的数据，二者之差再存储到内存地址0x108处，该指令执行完毕后，内存地址0x108处所存储的数据由0xAB变为0xA8；对于加1指令`incq 16(%rax)`,就是将内存地址0x110内存存储的数加1，结果是内存地址0x110处所存储的数据由0x13变成了0x14，最后一条指令`subq %rdx,%rax`是将寄存器`rax`内的值减去寄存器`rdx`内的值，最终寄存器`rax`的值由0x100变成0xFD,

0x100存的是0x100 -  0x3存在0x3 也就是0xFD
