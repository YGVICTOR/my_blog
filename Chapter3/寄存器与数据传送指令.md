在讲述第一章计算机系统漫游时，提到过计算机系统中信息的存储部件，相对于内存和硬盘，大家可能对寄存器会陌生一些，接下来我们详细介绍一下寄存器的相关知识，最早8086的处理器中，包含8个16位的通用寄存器，具体如图所示。

每个寄存器都有特殊的功能，它们的名字就反映了不同的用途。当处理器从16位扩展到32位时，寄存器的位数也随之扩展到了32位，直到今天64位的处理器中，原来8个16位寄存器已经扩展成了64位，除此之外，还增加了8个新的寄存器。在一般的程序中，不同的寄存器扮演着不同的角色，相应的编程规范规定了如何使用这些寄存器。

例如，寄存器`rax`用来保存函数的返回值，寄存器`rsp`用来保存程序栈的结束位置，除此之外，还有16个寄存器可以用来传递函数参数，在了解了这些寄存器的用法之后，再去理解汇编代码就会容易多了。

接下来我们看一下指令的相关知识。大多数指令包含两部分，<u>**操作码和操作数**</u>，例如，图中的这几条指令，`movq`,`addq`,'`subq`,这部分被定义为操作码，它决定了CPU执行操作的类型，操作码之后的这部分是操作数，大多数指令具有一个或者多个操作数，不过像`ret`返回指令，是没有操作数的。

不同指令的操作数大致可以分为三类，<u>**分别是立即数，寄存器，以及内存引用**</u>，在AT&T格式的汇编中，立即数是以$开头的，后面跟一个整数，不过这个整数需要满足标准C语言的定义；操作数是寄存器的情况也比较容易理解，即使在64位的处理器上，不仅64位的寄存器可以作为操作数，32位，16位甚至8位的寄存器都可以作为操作数。需要注意的是，图中这种寄存器带了小括号的情况，它所表示的是内存引用。

接下来，我们重点看一下内存引用的情况，我们通常将内存抽象为一个字节数组，当需要从内存中存取数据时，需要获取目的数据的起始地址**addr**,以及数据长度**b**,我们使用符号$$M_b[addr]$$ 来表示内存引用。为了简便，通常会省略下标b，最常用的内存引用包含4部分，分别是一个立即数，一个基址寄存器，一个变址寄存器和一个比例因子，
$$
Imm \rightarrow Immediate(立即数) \\
r_b \rightarrow Base Register(基址寄存器) \\
r_i \rightarrow Index Register(变址寄存器) \\
s \rightarrow Scale Factor(比例因子)[1,2,4,8]
$$
引用数组元素时，会使用到这种通用的形式
$$
Imm(r_b,r_i,s) \rightarrow Imm + R[r_b] + R[r_i]*s
$$
比例因子的取值必须是1，2，4，8；实际上，比例因子的取值是与源代码中定义的数组类型是相关的。编译器会根据数组类型来确定比例因子的数值，例如，定义**char**类型的数组，比例因子就是1，**int**类型，比例因子就是4，至于**double**类型，比例因子就是8，其他形式的内存引用都是这种普通形式的变种，省略了其中的某些部分，图中列出了内存引用的其他形式，需要特别注意到两种是不带$符号的立即数，和带了括号的寄存器。

在上一节中，我们提到过move类指令，它包含`movb`,`movw`,`movl`以及`movq`这四条指令，这些指令执行相同的操作，都是把数据从源位置复制到目的位置，主要区别，在于他们所操作的数据大小不同，具体如图所示。

对于`MOV`类指令，含有两个操作数，一个称为源操作数，一个称为目的操作数；对于<u>**源操作数**</u>，可以是<u>**立即数，一个寄存器，或者是内存引用**</u>；由于目的操作数是用来存放源操作数的内容，所以目的操作数要么是一个寄存器，要么是一个内存引用，注意，目的操作数不能是一个立即数；初次之外，x86-64处理器有一条限制，就是`mov`指令的源操作数和目的操作数不能都是内存的地址，

当需要将一个数从内存的一个位置复制到另一个位置时，应该如何操作？

此时，需要两条`mov`指令来完成，

```shell
mov memory, register
mov register, memory
```

第一条指令将内存源位置的数据加载到寄存器，第二条指令再将该寄存器的值写入内存的目的位置。接下来，我们看几个有关`mov`指令的例子，图中的指令给出了不同原操作数和目的操作数的组合，第一个是源操作数，第二个是目的操作数，mov指令的后缀与寄存器的大小一定得是匹配的，例如寄存器`%eax`是32位，与双字l对应，寄存器`%al`是8位，与字节b对应，除此之外，`mov`指令还有一个特殊的情况需要了解一下，当`movq`指令的源操作数是64位时，该立即数只能是32位的补码表示，然后对该数值进行符号位扩展之后，将得到的64位数传送到目的位置，这个限制会带来一个问题，，当立即数是64位时应该如何处理？这里引入了一个新的指令，`movabsq`，该指令的源操作数可以是任意的64位立即数，需要注意的是，目的操作数仅能是寄存器。

接下来，我们通过一个例子来看一下，使用`mov`指令进行数据传送时，对于目的寄存器的修改结果是怎么样的

```shell
movabsq $0x0011223344556677,	%rax
movb    $-1				        %al
movw    $-1                     %ax
movl    $-1                     %eax
```

首先，使用movabsq指令将一个64位的立即数复制到寄存器`rax`,

此时，寄存器`rax`内保存的数值如图所示、

接下来，使用movb指令将立即数-1复制到寄存器`al`，寄存器`al`的长度为8，与`movb`指令所操作的数据大小一致。此时，寄存器`rax`的低8位发生了改变， 次数寄存器`rax`的低16位发生了改变。当指令``movl``将立即数-1复制到寄存器`eax`时，此时寄存器`rax`不仅仅是低32位发生了变化，而且高32位也发生了变化，当`movl`的目的操作数是寄存器时，它会把该寄存器的高4节设置位0，这是x86-64处理器的一个规定。即任何位寄存器生成32位值的指令都会把该寄存器的高位部分置为0，

以上介绍的都是源操作数与目的操作数大小一致的情况。当源操作数数位小于目的操作数时，我们需要对目的操作数剩余的字节进行0扩展或者符号位扩展，零扩展数据传送指令有五条，其中字符z是zero的缩写。指令最后的两个字符都是大小指标符，第一个字母表示源操作数的大小，第二个字母表示目的操作数的大小。

符号位扩展传送指令有6条，其中字符s是sign的缩写，同样，指令最后的两个字符也是大小指示符。

对比零扩展和符号位扩展，我们可以发现符号位扩展比零扩展多了一条4字节到8字节的扩展指令，为什么零扩展没有`movzlq`的指令呢？是因为这种情况的数据传送可以使用`movl`指令来实现；

最后，符号位扩展还有一条没有操作数的特殊指令`cltq`,该指令的源操作数总是寄存器`eax`,目的操作数总是寄存器`rax`, 	`cltq`的效果和 `movslq %eax, %rax`