Chapter 3: Machine-Level Representation of Programs(程序的机器级表示)

在第一章讲述计算机漫游时，我们曾提到过编译系统的工作流程。本节我们详细介绍一下C语言、汇编代码以及机器代码之间的关系。理解汇编代码与原始C代码之间的关系，是理解计算机如何执行程序的关键一步。因此，稍微花一些时间来学习一下汇编语言，对理解计算机系统是非常有必要的。

![image-20240616113048546](.\pic\image-20240616113048546.png)

我们先来简单了解一下Intel处理器的发展历史。1978年Intel发布了第一款微处理器-8086，在接下来的四十多年里，Intel不断地推出新的处理器，从最早的16位扩展到32位，近些年又扩展到64位，视频中代码的运行环境就是Intel-x86-64位的处理器，操作系统是linux。

![image-20240616113228405](.\pic\image-20240616113228405.png)

接下来，我们看一个C代码的例子，这个示例中包含两个源文件，一个是main.c，另外一个是mstore.c,我们可以通过图中的命令编译这些代码，其中`gcc`指的就是`gcc`编译器，它是linux系统上**默认的编译器** ，其中编译选项`-Og`是用来告诉编译器生成符合原始C代码整体结构的机器代码。在实际项目中，为了获得更高的性能，会使用`-O1`或者`-O2`,甚至更高的编译优化选项。但是使用高级别的优化产生的代码会严重变形，导致产生的机器代码与最初的源代码之间的关系难以理解，此处为了方便理解，因此选择`-Og`这个优化选项。`-o`后面跟的参数`prog`表示生成可执行文件的文件名。关于更多链接方面的知识，将会在第七章做更详细的讲解。

![image-20240616113458558](.\pic\image-20240616113458558.png)

```shell
linux > gcc -Og -o prog main.c mstore.c
```

首先，我们以源文件`mstore.c`为例，看一下代码与汇编代码之间的关系，使用图中的这条命令可以生成`mstore.c`所对应的汇编文件`mstore.s`,其中`-S`这个编译选项就是告诉编译器`GCC`产生的文件为汇编文件，我们可以用编辑器**(vim)**打开这个汇编文件。

![image-20240616113653433](.\pic\image-20240616113653433.png)

其中以"."开头的行都是指导汇编器和链接器工作的伪指令，也就是说我们完全可以忽略这些以“."开头的行。

![image-20240616113819537](.\pic\image-20240616113819537.png)

删除了无关的信息之后，剩余这些汇编代码与源文件中C代码是相关的，接下来我们看一下这段C程序所对应的第一条汇编代码。`pushq`这条指令的意思是将寄存器`rbx`的值压入程序栈进行保存。

![image-20240615003536919](.\pic\image-20240615003536919.png)

在IntelX86-64的处理器中包含了16个通用目的的寄存器，这些寄存器用来存**放整数数据和指针**，图中显示的这16个寄存器，它们的名字都是%r开头的。

![image-20240616114026991](.\pic\image-20240616114026991.png)

在详细介绍寄存器之前，我们首先需要搞清楚两个概念，**调用者保存寄存器**和**被调用者保存寄存器**，例如图中的这个例子，函数A调用了函数B，因此函数A称为调用者，函数B称为被调用者，由于调用了函数B，寄存器`rbx`在函数B中被修改了，逻辑上寄存器rbx的内容在调用函数B的前后应该保持一致。

![image-20240616114147025](.\pic\image-20240616114147025.png)

解决这个问题有两个策略。一个是函数A在调用函数B之前，提前保存寄存器`rbx`的内容，执行完函数B之后，再恢复寄存器`rbx`原来存储的内容，这种策略就称为**<u>调用者保存</u>**。

![image-20240616114259312](.\pic\image-20240616114259312.png)

另外一个策略就是函数B在使用寄存器rbx之前，先保存寄存器`rbx`的值，在函数B返回之前，先恢复寄存器`rbx`原来存储的内容，这种策略被称之为<u>**被调用者保存**</u>。

![image-20240616114349032](.\pic\image-20240616114349032.png)

对于具体使用哪一种策略，不同的寄存器被定义为不同的策略，具体如图所示。

![image-20240616102840920](.\pic\image-20240616102840920.png)

<u>**寄存器`rbx`被定义为被调用者保存寄存器**</u>(callee-saved register)，因此，pushq就是用来保存寄存器`rbx`的内容，在函数返回之前，使用了`pop`命令，恢复寄存器`rbx`的内容。

![image-20240616114606057](.\pic\image-20240616114606057.png)



第二行汇编代码的含义是将寄存器`rdx`的内容复制到`rbx`,根据寄存器用法的定义，函数multstore的三个参数分别保存在寄存器`rdi`,`rsi`和`rdx`中，这条指令执行结束后，寄存器`rdx`与寄存器`rbx`内容一致，都是dest指针所指向内存的地址，

![image-20240616114712621](.\pic\image-20240616114712621.png)

`mov`指定的后缀q,表示数据的大小，由于早期的机器是16位的，后来才扩展到32位，因此intel用字(word)表示16位的数据类型。所以，32位的数据类型称为双字，64位的数据类型称为四字。图中的表格给出了C语言的基本数据类型对应的汇编后缀表示，

![image-20240616115054442](.\pic\image-20240616115054442.png)

大多数GCC生成的汇编指令都有一个字符后缀来来表示操作数的大小，例如数据传送指令就有四个变种，分别为`movb`,`movw`,`movl`以及`movq`，

其中`movb`是Move Byte的缩写,表示传送字节；`movw`是Move Word的缩写，表示传送字，`movl`表示传送双字，其中l是long word的缩写；`movq`则表示传送4字。

call指令对应于C代码中的函数调用，这一行代码比较容易理解，该函数的返回值会被保存在寄存器`rax`中，因此，寄存器`rax`中保存了x和y的乘积的结果。

![image-20240616115242348](.\pic\image-20240616115242348.png)

下一条指令将寄存器`rax`的值传送到内存保存，内存的地址就是保存在寄存器 `rbx`中，最后一条指令ret，就是函数返回。

![image-20240616120119817](.\pic\image-20240616120119817.png)

接下来我们看一下C代码是如何被翻译成机器代码的，我们只需要将编译选项从-S替换为-c

```shell
linux > gcc -Og -S mstore.c
linux > gcc -Og -c mstore.c
```

执行这条命令，即可生产`mstore.c`对应的机器代码文件`mstore.o`,由于该文件是二进制的，所以无法直接查看，这里我们需要有一个反汇编工具`-objdump`;

![image-20240616120235203](.\pic\image-20240616120235203.png)

汇编器将汇编代码翻译为二进制机器代码，那么反汇编器就是将机器代码翻译成汇编代码，通过图中的命令，我们可以查看mstore.中的相关信息。

```shell
linux > objdump -d mstore.o
```

通过对比反汇编得到的汇编代码与编译器直接生成的汇编代码，可以发现二者存在细微的差别，反汇编代码省略了很多指令的后缀"q"，但在`call`和`ret`指令添加了后缀q，由于q只是代表大小指示符，大多数情况下是可以省略的。

![image-20240616120323405](.\pic\image-20240616120323405.png)

通过上述描述，我们大概了解了C代码，汇编代码，机器代码之间的关系。

**总结**

上述汇编执行过程如下：

1. 被调用者保存机制先调用push存储寄存器`%rbx`中的值；
2. 修改`%rbx`寄存器，将函数第三个参数的值直接放入寄存器`rbx`中；
3. 调用函数mult2，函数的返回值放入寄存器`rax`中；
4. 找到寄存器`rbx`指向的地址，将那个地址上的值修改为`rax`寄存器的值（也就是mult2函数的返回值）
5. 被调用者保存机制将寄存器`rbx`中的值恢复
6. 结束程序。