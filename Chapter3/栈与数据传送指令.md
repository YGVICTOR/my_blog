上一节我们讲述了数据传送指令的相关知识，本期先从计算机系统的角度，看一下程序执行时数据传送的情况。

在第一章，我们提到过helloworld程序加载运行的大致过程。最初，可执行文件是保存在硬盘上，通过shell程序，将可执行程序从硬盘加载到内存。此时，程序指令以及数据都保存在内存中，CPU要执行程序，需要从内存中读取指令和数据。实际上，在一些程序的执行过程中，需要在CPU的内存之间进行频繁的数据存取。例如，CPU执行一个简单的加法操作$ c = a + b$ , 那么首先通过CPU执行数据传送指令将a和b的值从内存读取到寄存器内，寄存器就是CPU内的一种数据存储部件，只不过是容量比较小。我们以x86-64处理器为例，寄存器`rax`的大小是64个比特位，也就是8个字节，如果变量a是long类型，需要占用8个字节，因此，寄存器`rax`全部的数据位都用来保存变量a,如果变量a是int类型，那么只需要用4个字节来存储该变量，那么，只需要用到寄存器的低32位就够了，如果变量a是short类型，则只需要用到寄存器的低16位，对于寄存器`rax`,如果使用全部的64位，用符号`%rax`来表示，如果只用到低32位，可以用符号`%eax`来表示，对于低16位和低8位，则分别用`%ax`和`%al`来表示，虽然使用了不同的表示符号，但实际上仅仅只是针对同一寄存器的不同数位进行操作。处理完成加法运算之后，再通过一条数据传送指令将计算结果保存到内存中。正是因为数据传送在计算机系统中是一个非常频繁的操作，所以了解一下数据传输的指令对理解计算机系统会有很大的帮助，。接下来我们看一个数据传送的代码实例。

```C
int main(){
    long a = 4;
    long b = exchange(&a,3);
    printf("a = %ld, b = %ld \n",a,b);
    return 0;
}

long exchange(long *xp, long y){
    long x = *xp;
    *xp = y;
    return x;
}
```

`main`函数中定义了变量a，并且赋值为4，随后调用了`exchange`函数，该函数执行返回后，变量a的值会替换为3，变量b将保存变量a原来的值4

```shell
$ linux > a = 3, b= 4
```

我们重点看一下函数`exchange`对应的汇编指令

```shell
exchange:
	movq (%rdi), %rax
	movq %rsi, (%rdi)
	ret
```

从汇编的角度看，`exchange`将第一个参数的地址存取的值返回，放入`%rax`寄存器；然后将第二个参数的值复制到第一个参数那个地址里；

函数`exchange`由三条指令实现，包含两条数据传送指令和一条返回指令，根据寄存器使用的惯例，寄存器`%rdi`和`%rsi`分别用来保存函数传递的第一个和第二个参数，因此寄存器`rdi`中保存了xp的值，寄存器`rsi`保存了变量y的值，这段汇编代码并没有显式地将这部分表示出来，需要注意一下，第一条`mov`指令从内存中读取数据放入到寄存器，内存地址保存在寄存器`rdi`中，目的操作数是寄存器`rax`,由于最后`exchange`函数需要返回变量x的值，所以这里直接将变量x放入寄存器`rax`中，第二条`mov`指令，将变量y的值写入到内存里，变量y存储在寄存器`rsi`中，内存地址保存在寄存器`rdi`中，也就是xp指向的内存的位置。通过这个例子，我们可以看到C语言中所谓的指针其实就是地址。此外，还有两个数据传送指令需要借助程序栈。栈是一种数据结构，通过`push`操作把数据压入栈，通过`pop`操作删除数据，栈具有一个特性，<u>**就是弹出的数据永远是最近被压入的且仍然在栈中**</u>，这个程序栈本质是内存的一个区域，在第一章计算机系统漫游时，我们曾分析过程序运行时的内存分布。图中的这个区域就是程序栈，栈的增长方向是从高地址向低地址。<u>**因此，栈顶元素是所有栈中元素地址最低的**</u>，根据惯例，栈是倒过来画的，栈顶在底部，栈底在顶部，

例如我们需要保存寄存器`rax`内存的数据0x123,可以使用`pushq %rax`指令把数据压入栈内，该指令执行的过程可以分解为两步，首先指向栈顶的寄存器`rsp`进行一个减法操作，例如，压栈之前，栈顶指针`rsp`指向栈顶位置，此处地址为0x108，压栈的第一步就是寄存器`rsp`的值减8，此时指向内存地址是0x100，然后将需要保存的数据复制到新的栈顶地址，此时内存地址0x100处将保存寄存器`rax`中存储的数据0x123，实际上`pushq`指令等效于

```shell
sub $8, %rsp
mov %rax, (%rsp)
```

它们之间的区别是`pushq`这一条指令只需要一个字节，而图中的这两条指令需要8个字节存储，<u>**说到底，`push`指令的本质还是将数据写入到内存中**</u>，那么与之相对应的`pop`指令就是从内存中读取数据，并修改栈顶指针，例如`popq %rbx`就是将栈顶保存到数据复制到寄存器`rbx`中，`pop`指令的操作也可以分解为两步，

```shell
movq (%rsp), %rbx
add $8, %rsp
```

首先从栈顶位置读出数据，复制到寄存器`rbx`,此时栈顶指针`rsp`指向的内存地址是`0x100`, 然后将栈顶指针加8，pop后栈顶指针rsp指向的内存地址是`0x108`, pop后栈顶指针`rsp`指向的地址是0x108,实际上`pop`指令是通过修改栈顶指针所指向的内存地址来实现数据删除的，此时内存地址0x100内所保存的数据0x123仍然存在，

直到下次`push`操作，此处保存的数值才会被覆盖。